题目：
https://leetcode-cn.com/problems/unique-binary-search-trees/

由于1,2...n这个数列是递增的，所以我们从任意一个位置“提起”这课树，都满足二叉搜索树的这个条件：左边儿子数小于爸爸数，右边儿子数大于爸爸数
 
从1,2,...n数列构建搜索树，实际上只是一个不断细分的过程
例如，我要用[1,2,3,4,5,6]构建
首先，提起"2"作为树根，[1]为左子树，[3,4,5,6]为右子树
 
现在就变成了一个更小的问题：如何用[3,4,5,6]构建搜索树？
比如，我们可以提起"5"作为树根，[3,4]是左子树，[6]是右子树
 
现在就变成了一个更更小的问题：如何用[3,4]构建搜索树？
那么这里就可以提起“3”作为树根，[4]是右子树
或"4"作为树根，[3]是左子树
 
可见n=6时的问题是可以不断拆分成更小的问题的
 
假设f(n) = 我们有n个数字时可以构建几种搜索树
我们可以很容易得知几个简单情况 f(0) = 1, f(1) = 1, f(2) = 2
(注：这里的f(0)可以理解为=1也可以理解为=0，这个不重要，我们这里理解为=1,即没有数字时只有一种情况，就是空的情况）
 
那n=3时呢？
我们来看[1,2,3]
如果提起1作为树根，左边有f(0)种情况，右边f(2)种情况，左右搭配一共有f(0)*f(2)种情况
如果提起2作为树根，左边有f(1)种情况，右边f(1)种情况，左右搭配一共有f(1)*f(1)种情况
如果提起3作为树根，左边有f(2)种情况，右边f(0)种情况，左右搭配一共有f(2)*f(0)种情况
容易得知f(3) = f(0)*f(2) + f(1)*f(1) + f(2)*f(0)
 
同理,
f(4) = f(0)*f(3) + f(1)*f(2) + f(2)*f(1) + f(3)*f(0)
f(5) = f(0)*f(4) + f(1)*f(3) + f(2)*f(2) + f(3)*f(1) + f(4)*f(0)
......
发现了咩？
对于每一个n，其式子都是有规律的
每一项两个f()的数字加起来都等于n-1
 
既然我们已知f(0) = 1, f(1) = 1
那么就可以先算出f(2),再算出f(3),然后f(4)也可以算了...
计算过程中可以把这些存起来，方便随时使用
最后得到的f(n)就是我们需要的解了


 class Solution:
    def numTrees(self, n: int) -> int:
        store = [1,1] #f(0),f(1)
        if n <= 1:
            return store[n]
        for m in range(2,n+1):
            s = m-1
            count = 0
            for i in range(m):
                count += store[i]*store[s-i]
            store.append(count)
        return store[n]

class Solution:
    def numTrees(self, n: int) -> int:
        dp = [1,1,2]
        if n <= 2:
            return dp[n]
        for i in range(3,n+1):
            s = i - 1
            count = 0 
            for m in range(i):
                count += dp[m]*dp[s-m]
            dp.append(count)
        return dp[n]
        
        
        
